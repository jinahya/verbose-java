== Numbers and Characters

[quote, Unknown]
________________________________________________________________________________
컴퓨터는 0과 1밖에 모르는 바보다.
________________________________________________________________________________

[quote, 지은이]
________________________________________________________________________________
0과 1밖에 모르는 어떤 '바보' 보다 더 똑똑한 사람을 본 적이 없다.
________________________________________________________________________________

본 장에서는 '숫자' 밖에 모르는 컴퓨터와 '문자' 를 사용하는 사람 사이에 종종 발생하는 문제점들을 해결하는 방법들을 살펴본다. 우선 자바의 자료형에 대해 간략히 알아본 후 http://tools.ietf.org/html/rfc4648#section-8[Base 16 Encoding]과 https://tools.ietf.org/html/rfc3986#section-2.1[Percent-Encoding]에 대해 알아보자.

=== Types and Values

****
자바의 `int` 형은 몇 비트인가요? `signed` 인가요? 아니면 `unsigned` 인가요? 표현할 수 있는 최소값과 최대값은 무엇인가요?
****

위의 질문들에 대한 올바른 답을 아직 모른다면 [https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html[JSL 4. Types, Values, and Variables]] 항목을 꼭 읽어보도록 하자. 원시형을 중심으로 해당 항목을 요약하자면 다음과 같다.

- 자바 프로그래밍 언어에는 두가지 데이터 형이 있다. 하나는 원시형(primitive types)이고 또 다른 하나는 참조형(reference types)이다.
- 원시형(primitive types)에는 `boolean` 과 수치형(numeric types)이 있다.
- 수치형(numeric types)에는 정수형(integral types)과 부동소수점형(floating-point types)이 있다.
- 정수형(integral types)에는 `byte`, `short`, `int`, `long`, 그리고 `char` 가 이다.
- 부동소수점형(floating-point types)에는 `float` 과 `double` 이 있다.

[options="header"]
.Primitive types
|===============================================================================
 |type       |                   |          |size|signed
 |NumericType|IntegralType      m|*byte*   m| *8*|yes
 |           |                  m|*short*  m|*16*|yes
 |           |                  m|*int*    m|*32*|yes
 |           |                  m|*long*   m|*64*|yes
 |           |                  m|*char*   m|*16*|
 |           |FloatingPointType m|*float*  m|*32*|yes
 |           |                  m|*double* m|*64*|yes
m|*boolean*  |                   |          |    |
|===============================================================================

****
자바의 정수형(integral types) 중에 unsigned 형이 존재하는가? 있다면 무엇인가?
****

=== N-bit signed two's-compliment integers
N개의 비트로 이루어져 있고 부호를 가지며 2의 보수체계를 사용하는 정수형로 표현할 수 있는 값의 범위는 무엇일까? 아래 세개의 비트를 가지고 실험해 보자. `000` 부터 시계방향으로 1씩 더하면서 계산해 보자.

[source,text]
.3-bit signed two's-compliment integer
----
       +1
         \ 000  0
  -1  111 \ 001  1
   -2  110 \ 010  2
    -3  101 \ 011  3  MAX
MIN  -4  100 \
              +1
----

보는 바와 같이 `011` 에서 `1` 을 더했을때 `100` 이 되지만 첫번째 비트가 `1` 이므로 음수(`-4`)로 처리된다. 최대값은 첫번째 비트가 `0` 이고 나머지 모든 비트가 `1` 인 값이고 최소값은 첫번째 비트가 `1` 이고 나머지 비트가 모두 `0` 인 값이다. 이를 수식으로 표현하면 최대값은 `+2^n-1^-1` 이고 최소값은 `-2^n-1^` 이다.

****
크기가 1 비트이고 부호를 가지며 2의 보수 체계를 사용하는 정수형으로 표현할 수 있는 최대값과 최소값은 무엇인가?
****

=== hex-codec-api

거의 모든 컴퓨터들은 자료를 저장할 때, `octet` 으로 불리는, 여덟개의 비트로 구성된 최소 단위의 숫자들로 나누어 저장한다. 'a' 라는 문자는 (`US-ASCII` 로 인코딩 되었을 때) `01100001` 로, '홍' 이라는 문자는 (`UTF-8` 로 인코딩 되었을 때) `111011011 00110011 0001101` 로 저장된다. 아래 표에 여덟개의 비트로 표현할 수 있는 몇몇 값들을 10진법, 8진법, 2진법, 그리고 자바의 `byte` 값으로 표현하였다.

[cols=">1,>1,>1,>1,<2",frame="top",options="header"]
.8-bit values
|====
|base10|base8|base2     |byte  |notes
|   `0`|  `0`|       `0`|   `0`|
|  `15`| `17`|    `1111`|  `15`|
|  `31`| `37`|   `11111`|  `31`|
|  `63`| `77`|  `111111`|  `63`|
| `127`|`177`| `1111111`| `127`|`Byte.MAX_VALUE`
| `128`|`200`|`10000000`|`-128`|`Byte.MIN_VALUE`
| `192`|`300`|`11000000`| `-64`|
| `224`|`340`|`11100000`| `-32`|
| `240`|`360`|`11110000`| `-16`|
| `255`|`377`|`11111111`|  `-1`|
|====

자바의 `byte` 형은 여덟개의 비트를 사용하고 부호를 가지며 2의 보수체계를 사용한다.

[source,text]
.8-bit signed two's-compliment integer
----
                         +1
                           \ 00000000  0
               -1  11111111 \ ........
                    ........ \ ........
                     ........ \ 01111111  127  Byte.MAX_VALUE
Byte.MIN_VALUE  -128  10000000 \
                                +1
----

거의 모든 문자셋의 기본이 되는 `US-ASCII` 문자셋에는 줄바뀜(CR, LF), 탭(TAB) 등의 제어 문자들과 보통의 자판에서 찾아볼 수 있는 문자들을 포함하여 `128`(`2^7^`)개의 코드가 정의되어 있다. 때문에 여덟개의 비트로 표현할 수 있는 `256`(`2^8^`)개의 수에 모든 문자를 할당하는 것이 불가능하다. 이를 해결하는 방법 중에 하나가 `base16`(`hex`) 로 표현하는 것이다. `base16` 표기는 여덟 개의 비트를 네 개씩 두 그룹으로 나눈 후에 각 그룹의 값을 미리 정의된 문자들 중 하나로 표현한다.

우선 아래와 같이 여덟 개의 비트를 네 개씩 두 그룹으로 나눈다.

[source,text]
----
index  7 6 5 4 3 2 1 0
upper  H H H H
lower          L L L L
----

그리고 (네 개의 비트로 표현되는) 각 그룹의 값(`0` ~ `15`)을 아래 표에 정의된 열 여섯개의 문자로 변경한다.

[cols=">, >, >, >", options="header"]
.hexadecimal encoding/decoding
|====
|decoded binary|decoded value|encoded character|encoded value
|           `0`|    `0 (0x0)`|            `'0'`|  `48 (0x30)`
|           `1`|    `1 (0x1)`|            `'1'`|  `49 (0x31)`
|          `10`|    `2 (0x2)`|            `'2'`|  `50 (0x32)`
|          `11`|    `3 (0x3)`|            `'3'`|  `51 (0x33)`
|         `100`|    `4 (0x4)`|            `'4'`|  `52 (0x34)`
|         `101`|    `5 (0x5)`|            `'5'`|  `53 (0x35)`
|         `110`|    `6 (0x6)`|            `'6'`|  `54 (0x36)`
|         `111`|    `7 (0x7)`|            `'7'`|  `55 (0x37)`
|        `1000`|    `8 (0x8)`|            `'8'`|  `56 (0x38)`
|        `1001`|    `9 (0x9)`|            `'9'`|  `57 (0x39)`
|        `1010`|   `10 (0xA)`|            `'A'`|  `65 (0x41)`
|        `1011`|   `11 (0xB)`|            `'B'`|  `66 (0x42)`
|        `1100`|   `12 (0xC)`|            `'C'`|  `67 (0x43)`
|        `1101`|   `13 (0xD)`|            `'D'`|  `68 (0x44)`
|        `1110`|   `14 (0xE)`|            `'E'`|  `69 (0x45)`
|        `1111`|   `15 (0xF)`|            `'F'`|  `70 (0x46)`
|====

NOTE: `10` 부터 `15` 까지의 숫자를 소문자(`'a'` 부터 `'f'` 까지)로 변환해도 된다.

아래는 `hello, world` 가 `base16` 으로 인코딩될 때 적용되는 방식을 보여준다.

[source,text]
----
    0                    7                      15                      23
    h  e  l  l  o  , SP  w  o  r  l  d
   -- -- -- -- -- -- -- -- -- -- -- --
0x 68 65 6C 6C 6F 2C 20 77 6F 72 6C 64
   --                --
    \                 \-----------------\
   -- --                               -- --
    6  8  6  5  6  C  6  C  6  F  2  C  2  0  7  7  6  F  7  2  6  C  6  4
   -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
0x 36 38 36 35 36 43 36 43 36 46 32 43 32 30 37 37 36 46 37 32 36 43 36 34
----

첫 번째 문자 `'h'` 의  ascii 값은 `104` 이다. 이를 이진수로 표현하면 `01101000` 이고 이를 각 네 자리씩으로 나눈 `0110` 과 `1000` 에 대해 첫 번째 그룹의 값(`6`)에 해당하는 문자 `'6'` 과 두 번째 그룹의 값(`8`)에 해당하는 문자 `'8'` 이 결과값이다.
[source,text]
----
'h' = 0110 1000  (104, 0x68)
      0110       (  6, 0x06)    =>    '6' = 0011 0110  ( 54, 0x36)
           1000  (  8, 0x08)    =>    '8' = 0011 1000  ( 56, 0x38)
----

일곱번 째 문자(`'{nbsp}'`)의 ascii 값은 `32`(`00100000`)이다. 이를 각 네 자리씩으로 나눈 `0010` 과 `0000` 에 대해 첫 번째 그룹의 값(`2`)에 해당하는 문자 `'2'` 와 두 번째 그룹의 값(`0`)에 해당하는 문자 `'0'` 이 결과값이다.
[source,text]
----
' ' = 0010 0000  ( 32, 0x20)
      0010       (  2, 0x02)    =>    '2' = 0011 0010  ( 50, 0x32)
           0000  (  0, 0x00)    =>    '0' = 0011 0000  ( 48, 0x30)
----

hex-codec-api 모듈에는 `Base 16 Encoding` 을 위한 두 개의 인터페이스가 정의되어 있다.

==== HexEncoder.java

숫자들을 `base16` 문자들로 인코딩하기 위한 인터페이스이다.

[source,java]
.HexEncoder.java
----
@FunctionalInterface
public interface HexEncoder {

    // 주어진 숫자(octet)를 인코딩하여 hex 문자 두개를 버퍼에 담는다.
    // 버퍼(encoded)의 remaining 값이 2 보다 작으면 BufferOverflowException 을 던진다.
    void encodeOctet(int decoded, ByteBuffer encoded);
}
----

`HexEncoder` 인터페이스에는 다음과 같은 `default` 메서드들이 정의되어 있다.

[source,java]
.HexEncoder.java#encode(ByteBuffer,ByteBuffer)
----
    // decoded 버퍼의 바이트들을 인코딩하고 그 결과를 encoded 버퍼에 담는다.
    // decoded 버퍼에서 소비된 바이트의 개수를 반환한다.
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexEncoder.java[lines=42..55]
----
<1> `decoded` 버퍼에 읽을 바이트들이 남아 있고 `encoded` 버퍼에 최소한 두 개의 바이트를 기록할 수 있는 동안 `encode(int, ByteBuffer)` 를 호출한다.

[source,java]
.HexEncoder.java#encode(ByteBuffer)
----
    // encoded 버퍼의 모든 바이트들을 인코딩하고 결과를 새 버퍼에 담아 반환한다.
    // 반환되는 버퍼는 바로 읽을 수 있는 상태이다.
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexEncoder.java[lines=64..72]
----
<1> `decoded` 버퍼에서 읽을 수 있는 바이트 개수의 두 배만큼의 버퍼를 생생한다.
<2> 두 버퍼를 `encode(ByteBuffer, ByteBuffer)` 메서드에 전달한다.
<3> 반환할 버퍼를 뒤집어(flip) 바로 읽을 수 있는 상태로 만들다.

[source,java]
.HexEncoder.java#encode(String,Charset)
----
    // 주어진 문자열(encoded)을 인코딩하고 결과를 문자열로 반환한다.
    // 문자열(encoded)로부터 charset 을 이용하여 byte[] 를 얻어 인코드한다.
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexEncoder.java[lines=82..93]
----
<1> `charset` 을 이용해 주어진 문자열에서 입력 배열을 생성한다.
<2> 두배의 길이를 갖는 출력 배열을 생성한다.
<3> 이 두 배열을 감싸는 버퍼들을 `encoded(ByteBuffer, ByteBuffer)` 메서드에 전달한다.
<4> 출력 배열로부터 문자열을 생성하고 반환한다.

==== HexDecoder.java

`Base 16 Encoding` 으로 인코딩된 문자들을 숫자로 디코딩하기 위한 인터페이스이다.

[source,java]
.HexDecoder.java
----
@FunctionalInterface
public interface HexDecoder {

    // 버퍼에서 hex 문자 두개를 디코딩하고 그 결과값(octet)을 반환한다.
    // 버퍼에서 읽을 수 있는 바이트들의 개수가 두 개 이하이면 BufferUnderflowException 을 던진다.
    int decodeOctet(ByteBuffer encoded);
}
----

`HexDecoder` 인터페이스에도 `HexEncoder` 인터페이스에 정의된 `default` 메서드들과 각각 대응하는 `default` 메서드들이 정의되어 있다.

[source,java]
.HexDecoder.java#decode(ByteBuffer,ByteBuffer)
----
    // 입력 버퍼(encoded)에서 문자들을 디코딩하고 결과를 출력 버퍼(decoded)에 담는다.
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexDecoder.java[lines=42..55]
----
<1> `encoded` 버퍼에 읽을 바이트의 개수가 2개 이상 있고 `decoded` 버퍼에 쓸 수 있는 공간이 남아 있는 동안
<2> `decodeOctet(ByteBuffer)` 메서드에 `encoded` 버퍼를 전달하고 반환된 값을 `decoded` 버퍼에 담는다.

[source,java]
.HexDecoder.java#decode(ByteBuffer)
----
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexDecoder.java[lines=64..72]
----
<1> `encoded` 버퍼에서 읽을 수 있는 바이트 개수의 절반 만큼의 버퍼를 생성하고
<2> `encode(ByteBuffer,ByteBuffer)` 메서드에 전달해서 디코드한다.
<3> 반환할 버퍼를 뒤집어(flip) 읽을 수 있는 상태로 만든다.

[source,java]
.HexDecoder.java#decode(String,Charset)
----
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexDecoder.java[lines=82..93]
----
<1> 문자열로부터 입력 배열을 생성한다.
<2> 절반 만큼의 길이를 갖는 출력 배열을 생성한다.
<3> `decode(ByteBuffer, ByteBuffer)` 메서드에 전달해서 디코드한다.
<4> 출력 배열과 명시된 `charset` 을 이용하여 문자열을 생성한 후 반환한다.

==== HexOutputStream.java

기록되는 바이트들을 자동으로 `base16` 문자들로 바꾸어 기록하는 `OutputStream` 이다. {apidocs-javase}/java/io/FilterOutputStream.html[`java.io.FilterInputStream`] 클래스를 확장하여 작성되었다.

[source,java]
.HexOutputStream.java
----
public class HexOutputStream extends FilterOutputStream {

    // out: 인코딩된 문자들이 기록될 스트림
    // enc: 숫자들을 문자들로 변환하기 위한 인코더
    public HexOutputStream(final OutputStream out, final HexEncoder enc) {
        super(out); // <1>
        this.enc = enc;
    }

    protected HexEncoder enc;
    private ByteBuffer buf; // 인코딩 작업에 사용할 버퍼
}
----
<1> `out` 인자를 `FilterOutputStream` 클래스의 생성자로 넘긴다.

[TIP]
====
`FilterOutputStream` 클래스의 생성자는 `out` 인자가 `null` 인지 확인하지 않는다. 대신 `protected` 접근자를 가지는 `out` 필드를 통해 값을 수정할 수 있다. 아마도 `null` 을 이용하여 생성한 후 실제로 사용할 필요가 있을 때 게으르게(lazily) 초기화될(initialized) 수 있는 여지를 남겨둔 듯 하다. `HexOutputStream` 클래스의 생성자도 `enc` 인자가 `null` 인지 확인하지 않는다. `null` 값을 이용하여 생성한 후 다음과 같이 사용할 수도 있다.
[source,java]
----
final OutputStream hos = new HexOutputStream(null, null) {
    @Override
    public void write(final byte b) throws IOException {
        if (out == null) out = openFile(); // lazily
        if (enc == null) enc = loadEncoder(); // lazily
        super.write(b);
    }
};
----
====

===== OutputStream#close()

스트림을 닫고 사용되고 있는 다른 리소스들을 해제한다. {apidocs-javase}/java/io/FilterOutputStream.html#close--[`FilterOutputStream#close()`] 메서드는 `flush()` 메서드를 호출하고 `out` 객체의 `close()` 메서드를 호출한다. `HexOutputStream` 클래스에서는 별도로 재정의하지 않았다.

===== OutputStream#flush()

데이터가 중간에 쌓여(buffered)있다면 실제 목적지로 밀어낸다. {apidocs-javase}/java/io/FilterOutputStream.html#flush--[`FilterOutputStream#flush()`] 메서드는 `out` 객체의 `flush()` 메서드를 호출한다. `HexOutputStream` 클래스에서는 별도로 재정의하지 않았다.

===== OutputStream#write(byte[] b)

주어진 배열의 (모든) 값을 기록한다. `write(b, 0, b.length)` 를 호출한 것과 동일한 효과를 가져야 한다. {apidocs-javase}/java/io/FilterOutputStream.html#write-byte:A-[`FilterOutputStream#write(byte[\])`] 메서드는 `write(b,0,b.length)` 를 호출한다. `HexOutputStream` 클래스에서는 별도로 재정의하지 않았다.

===== OutputStream#write(byte[] b, int off, int len)

주어진 배열의 `off` 위치부터 `len` 만큼의 바이트들을 기록한다. {apidocs-javase}/java/io/FilterOutputStream.html#write-byte:A-int-int-[`FilterOutputStream#write(byte[\],int,int)`] 메서드는 각 바이트를 `write(int)` 메서드에 하나씩 전달한다. `HexOutputStream` 클래스에서는 별도로 재정의하지 않았다.

===== OutputStreamWrite(int b)

주어진 바이트를 기록한다. 하위 8 개의 비트들만 사용되고 상위 24 개의 비트들은 무시된다. {apidocs-javase}/java/io/FilterOutputStream.html#write-int-[`FilterOutputStream#write(int)`] 메서드는 `out` 객체의 `write(int)` 메서드에 주어진 값을 전달한다. `HexOutputStream` 클래스에서는 다음과 같이 재정의되었다.

[source,java]
.HexOutputStream.java#write(int)
----
    // 주어진 바이트를 두개의 hex 문자로 변환하여 기록한다.
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexOutputStream.java[lines=49..59]
----
<1> `buf` 가 `null` 이면 두개의 hex 문자를 담을수 있을 만큼의 크기로 생성한다.
<2> `HexEncoder` 인터페이스의 `encodeOctet(int, ByteBuffer)` 메서드를 이용해 주어진 바이트를 변환한다.
<3> 변환된 두개의 문자들을 `out` 에 기록한다.

[CAUTION]
====
`flush()` 메서드와 `close()` 메서드는 `out` 필드가 `null` 인지 확인하지 않는다.
[source,java]
.FilterOutputStream.java (http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/java/io/FilterOutputStream.java#FilterOutputStream.flush%28%29[7u40-b43])
----
public void flush() throws IOException {
    out.flush();
}
public void close() throws IOException {
    try {
      flush();
    } catch (IOException ignored) {
    }
    out.close();
}
----
이후의 소스를 보면 다음과 같이 개선되었지만 여전히 `flush()` 메서드에서는 `out` 필드가 `null` 인지 확인하지 않는다.
[source,java]
.FilterOutputStream.java (http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/io/FilterOutputStream.java#FilterOutputStream.flush%28%29[8u40-b25])
----
public void flush() throws IOException {
    out.flush();
}
public void close() throws IOException {
    try (OutputStream ostream = out) { // <1>
        flush(); // <2>
    }
}
----
<1> `ostream` 이 `null` 이면 `close()` 를 호출하지 않는다.
<2> `flush()` 는 호출된다.
====

==== HexInputStream.java

`HexDecoder` 인터페이스를 이용하여 hex 문자들을 바이트로 변환해서 읽어들이는 `InputStream` 이다. {apidocs-javase}/java/io/FilterInputStream.html[`FilterInputStream`] 클래스를 확장하여 만들어졌다.

[source,java]
.HexInputStream.java
----
public class HexInputStream extends FilterInputStream {

    // in : 인코딩된 문자들을 읽을 스트림
    // dec: 문자들을 숫자들로 변환하기 위한 디코더
    public HexInputStream(final InputStream in, final HexDecoder dec) {
        super(in); // <1>
        this.dec = dec;
    }

    protected HexDecoder dec;
    private ByteBuffer buf; // 디코딩 작업에 사용할 버퍼
----
<1> `in` 인자를 `FilterInputStream` 클래스의 생성자에 전달한다.

===== InputStream#available()

블럭(blocked)되지 않고 한번에 읽을 수 있는 (혹은 건너 뛸 수 있는) 바이트 개수를 반환한다. 스트림의 끝(`end-of-stream`)에 도달한 상태라면 `0` 을 반환한다. (어떤 서브클래스들은 `IOException` 을 던질 수도 있다.) {apidocs-javase}/java/io/FilterInputStream.html#available--[`FilterInputStream#available()`] 메서드는 `in` 객체의 `available()` 값을 반환한다. 다음과 같이 그 절반에 해당하는 값을 반환하도록 재정의되었다. (두 개의 바이트를 읽고 하나로 변환하므로 가용한 바이트의 개수도 반으로 줄였다.)

[source,java]
.HexInputStream.java#available()
----
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexInputStream.java[lines=54..57]
----

[CAUTION]
====
`available()` 메서드가 반환하는 값을 최적의(optimal) 버퍼 크기로 오해하면 안된다. 몇몇 `InputStream` 클래스들은 읽을 수 있는 모든 바이트들의 개수를 반환하다.

[source,java]
.WrongIoUtil.java#copy(File,File)
----
static void copy(final File src, final File dst) throws IOException {
    try(InputStream in = new FileInputStream(src)) {
        try(OutputStream out = new FileOutputStream(dst)) {
            final byte[] buf = new byte[in.available()]; // <1>
            for (int len; (len = in.read(buf)) != -1; ) {
                out.write(buf, 0, len);
            }
            out.flush();
        }
    }
}
----
<1> `in` 객체의 `available()` 메서드가 파일(`src`)의 전체 크기를 반환할 수도 있다.
====

===== InputStream#close()

스트림을 닫고 사용되고 있는 리소스들을 해제한다. {apidocs-javase}/java/io/FilterInputStream.html#close--[`FilterInputStream#cloes()`] 메서드는 `in` 객체에 `close()` 메서드를 호출한다. `HexInputStream` 클래스는 별도로 재정의하지 않는다.

===== InputStream#mark(int readlimit)

현재 위치를 표시(mark)한 후 `reset()` 메서드를 통해 다시 그 위치부터 읽을 수 있게 한다. `reset()` 메서드를 호출하기 전에 `readlimit` 보다 많은 바이트들이 소비되면 표시가 무효화(invalidate)된다. {apidocs-javase}/java/io/FilterInputStream.html#mark-int-[`FilterInputStream#mark(int)`] 메서드는 주어진 값을 `in` 객체의 `mark(int)` 메서드에 전달한다. `HexInputStream` 클래스는 다음과 같이 주어진 값의 절반의 값을 사용하도록 재정의되었다.

[source,java]
.HexInputStream.java#mark(int)
----
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexInputStream.java[lines=69..72]
----
CAUTION: `readlimit` 의 값이 `Integer.MAX_VALUE / 2` 보다 클 경우의 결과는 예상할 수 없다.

[NOTE]
====
`FilterInputStream` 클래스의 `mark(int)` 메서드와 `reset()` 메서드는 `synchronized` 메서드로 구현되었다.
[source,java]
.java.io.FilterInputStream.java#mark(int)
----
    public synchronized void mark(int readlimit) {
        in.mark(readlimit);
    }
----
[source,java]
.java.io.FilterInputStream.java#reset()
----
    public synchronized void reset() throws IOException {
        in.reset();
    }
----
`HexInputStream` 클래스도 `mark(int)` 메서드를 `synchronized` 키워드를 추가하여 재정의하였다.
====

===== InputStream#markSupported()

`mark()` 메서드와 `reset()` 메서드를 지원하는지 확인한다. {apidocs-javase}/java/io/FilterInputStream.html#markSupported--[`FilterInputStream#markSupported()`] 메서드는 `in` 객체의 `markSupported()` 값를 반환한다. `HexInptuStream` 클래스는 별도로 재정의하지 않았다.

===== InputStream#read()

바이트 하나를 읽는다. 반환되는 값은 `0` 부터 `255` 까지의 양수이다. 스트림의 끝(`end-of-stream`) 에 도달했으면 `-1` 을 반환한다. 이 메서드는 유효한 데이터가 준비될 때까지 블럭된다. {apidocs-javase}/api/java/io/FilterInputStream.html#read--[`FilterInputStream#read()`] 메서드는 `in` 객체의 `read()` 메서드 값을 반환한다. `HexInputStream` 클래스는 아래와 같이 바이트 두 개를 읽어서 하나로 변환한 후 반환하도록 재정의되었다.

[source,java]
.HexInputStream.java#read()
----
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexInputStream.java[lines=83..102]
----
<1> `buf` 의 값이 아직 `null` 이면 두개의 hex 문자를 담을 수 있을 만큼의 크기로 생성한다.
<2> 첫번째 바이트를 읽고 `buf` 에 담는다. 그 값이 `-1` 이면 `-1` 을 반환한다.
<3> 두번째 바이트를 읽고 `buf` 에 담는다. 그 값이 `-1` 이면 `EOFException` 을 던진다. (올바르게 인코드되었다면 두 개의 hex 문자들이 올바르게 읽혀져야 한다.)
<4> `HexDecoder` 인터페이스의 `decodeOctet(ByteBuffer)` 메서드를 이용하여 디코딩한 값을 반환한다.

===== InputStream#read(byte[] b)

주어진 배열의 첫 번째 위치부터 최대 배열의 길이만큼 바이트를 기록한 후 실제로 기록된 바이트 개수를 반환한다. 이미 스트림의 끝(`end-of-stream`)에 도달했다면 `-1` 을 반환한다. 배열의 크기보다 작은 수 많큼 읽힐 수도 있다. 이 메서드는 유효한 데이터가 준비될 때까지 블럭된다. `b` 의 길이(`length`) 가 `0` 이면 `0` 을 반환한다. `read(b, 0, b.length)` 를 호출한 것과 같은 효과를 가진다. {apidocs-javase}/java/io/FilterInputStream.html#read-byte:A-[`FilterInputStream#read(byte[\])`] 메서드는 `read(byte[],int,int)` 메서드에 `b`, `0`, `b.length` 를 전달하고 그 결과값을 반환한다. `HexInputStream` 클래스는 별도로 재정의하지 않았다.

[CAUTION]
====
주어진 배열(`b`)의 길이(`length`)가 `0` 이면 스트림의 끝(`end-of-stream`)에 도달한 것과는 상관없이 무조건 `0` 을 반환할 수 있다.
====

===== InputStream#read(byte[] b, int off, int len)

주어진 배열에 `off` 위치부터 최대 `len` 만큼의 바이트를 기록한 후 실제로 읽힌 바이트의 개수를 반환한다. 이미 스트림의 끝(`end-of-stream`)에 도달했다면 `-1` 을 반환한다. `len` 값보다 작을 수의 바이트를이 읽힐 수도 있다. 이 메서드는 유효한 데이터가 준비될 때까지 블럭된다. `len` 값이 `0` 이면 `0` 을 반환한다. {apidocs-javase}/java/io/FilterInputStream.html#read-byte:A-int-int-[`FilterInputStream#read(byte[],int,int)`] 메서드는 `in` 객체의 `read(byte[],int,int)` 메서드에 주어진 인자들을 전달한 후 그 결과값을 반환한다. `HexInputStream` 클래스는 다음과 같이 재정의된 `read()` 메서드를 사용하도록 재정의 되었다.

[source,java]
.HexInputStream.java#read(byte[],int,int)
----
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexInputStream.java[lines=117..138]
----
<1> `len` 만큼 `read()` 메서드가 반환하는 값으로 배열의 값을 변경한다. `read()` 메서드가 `-1` 을 반환하기 전까지 반복한다. 첫 번째 호출이 `-1` 을 반환하면 `-1` 을 반환한다.

[CAUTION]
====
`read(byte[])` 메서드와 마찬가지로 `len` 값이 `0` 이면 스트림의 끝(`end-of-stream`)에 도달한 것과는 상관없이 무조건 `0` 을 반환할 수 있다.
====

===== InputStream#reset()

`mark(int)` 메서드가 호출된 시점으로 스트림의 위치를 조정한다. 일반(general) 계약(contract, 규약) 사항은 좀 더 복잡하다.

* `markSupported` 메서드가 `true` 를 반환하는 경우,
** 스트림이 생성된 이후 아직 `mark` 메서드가 호출되지 않았거나 마지막으로 호출된 `mark` 메서드의 `readlimit` 값보다 많은 바이트를 이미 읽은 상태라면 `IOException` 을 던질(might) 수 있다.
** `IOException` 을 던지지 않았다면 마지막으로 `mark` 메서드가 호출된 이후 읽은 모든 바이트들을 (혹은 `mark` 메서드가 호출되지 않았다면 파일의 처음부터) 다시 읽을 수 있는 상태로 리셋된다. 그 후에 `reset` 메서드가 호출된 시점 이후의 바이트들이 읽혀진다.
* `markSupported` 메서드가 `false` 를 반한하는 경우,
** `reset` 메서드가 `IOException` 을 던질(may) 수 있다.
** `IOException` 을 던지지 않았다면 스트림의 형(type)과 그 스트림 객체가 생성된 방식에 의해 (미리) 정해진 상태로 리셋된다. 이후 읽는 바이트들은 스트림 형(type)에 따라 결정된다.

{apidocs-javase}/java/io/FilterInputStream.html#reset--[`FilterInptuStream#reset()`] 메서드는 `in` 객체에 `reset()` 메서드를 호출한다. `HexInputStream` 클래스에서는 별도로 재정의 하지 않았다.

===== InputStream#skip(long n)

`n` 만큼의 바이트를 건너뛴다(버린다). (여러가지 이유로 인해) `n` 보다 적게 건너 뛴(`0` 만큼일 수도 있는) 값이 반환될 수 있다. http://docs.oracle.com/javase/8/docs/api/java/io/FilterInputStream.html#skip-long-[`FilterInputStream#skip(long)`] 메서드는 `in.skip(n)` 값을 반환한다. `HexInputStream` 클래스는 아래와 같이 주어진 값보다 최대 1이 작은 짝수만큼 시도하고 홀수만큼 건너뛰었으면 무조건 하나를 더 소비한다.

[source,java]
.HexInputStream.java#skip(long)
----
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexInputStream.java[lines=151..161]
----
<1> `n` 을 기준으로 (최대 1만큼 작은) 짝수만큼 시도한다.
<2> 실제로 건너뛴 개수가 홀수이면 하나를 더 읽어서 버린다.
<3> 건너뛴 만큼의 절반에 해당하는 값을 반환한다.

==== FilterChannel.java
이제 `HexOutputStream` 클래스와 `HexInputStream` 클래스가 수행하는 기능을 `java.nio.channels` 패키지에 정의된 클래스들을 사용하여 구현해 보자. `FilterOutputStream` 과 `FilterInputStream` 에 해당하는 클래스들이 존재하지 않으므로 `WritableByteChannel` 인터페이스와 `ReadableByteChanel` 인터페이스가 공통으로 확장하는 `java.nio.channels.Channel` 인터페이스를 기반으로 추상클래스를 하나 정의하고 공통의 기능을 미리 구현하도록 하겠다.

[source,java]
.FilterChannel.java
----
public class FilterChannel<T extends Channel> implements Channel {

    // channel : 실제 데이터가 기록되거나 읽혀질 채널
    public FilterChannel(final T channel) {
        super();
        this.channel = channel;
    }

    protected T channel;
}
----

===== Channel#isOpen()

채널이 열려 있는지 확인한다. `HexChannel#isOpen()` 메서드는 `channel` 의 `isOpen()` 을 호출하도록 구현되었다.

[source,java]
.FilterChannel.java#isOpen()
----
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/FilterChannel.java[lines=45..48]
----
<1> `channel` 이 `null` 이면 `NullPointerException` 이 발생한다.

===== Channel#close();

채널을 닫는다. `FilterChannel#close()` 메서드는 `channel` 이 `null` 이 아닐 경우에 한해 `channel` 에 직접 호출하도록 구현되었다.

[source,java]
.FilterChannel.java#close()
----
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/FilterChannel.java[lines=57..62]
----

==== WritableFilterChannel.java

`FilterChannel` 클래스를 확장하여 `WritableByteChannel` 형의 객체를 `channel` 의 값으로 사용하는 클래스이다.

[source,java]
.WritableFilterChannel.java
----
public class WritableFilterChannel<T extends WritableByteChannel>
        extends FilterChannel<T>
        implements WritableByteChannel {

    public WritableFilterChannel(final T channel) {
        super(channel);
    }
}
----

===== WritableByteChannel#write(ByteBuffer)

==== ReadableFilterChannel.java

`FilterChannel` 클래스를 확장하여 `ReadableByteChannel` 형의 객체를 `channel` 의 값으로 사용하는 클래스이다.

[source,java]
.ReadableFilterChannel.java
----
public class ReadableFilterChannel<T extends ReadableByteChannel>
        extends FilterChannel<T>
        implements ReadableByteChannel {

    public ReadableFilterChannel(final T channel) {
        super(channel);
    }
}
----

===== ReadableByteChannel#read(ByteBuffer)

==== WritableHexChannel.java

`HexEncoder` 인터페이스를 이용해 `write(ByteBuffer)` 메서드에 전달된 바이트들을 `base16` 문자들로 변환하여 기록하는 체널이다.

[source,java]
.WritableHexChannel.java
----
public class WritableHexChannel<T extends WritableByteChannel>
        extends WritableFilterChannel<T> {

    // channel: 변환된 문자들을 기록할 채널
    // encoder: 숫자를 문자로 변활할 때 사용할 인코더
    public WritableHexChannel(final T channel, final HexEncoder encoder) {
        super(channel);
        this.encoder = encoder;
    }

    protected HexEncoder encoder;
}
----

`write(ByteBuffer)` 메서드를 다음과 같이 재정의하였다.

[source,java]
.WritableHexChannel.java#write(ByteBuffer)
----
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/WritableHexChannel.java[lines=48..55]
----
<1> `src` 에 남아 있는 바이트 개수의 두배의 용량을 가지는 버퍼를 생성한다.
<2> `HexEncoder` 인터페이스의 `encode(ByteBuffer,ByteBuffer)` 메서드를 이용하여 변환한다.
<3> 변환된 바이트들을 `channel` 에 기록한다.

==== ReadableHexChannel.java

`HexDecoder` 인터페이스를 이용하여 `base16` 으로 변환된 문자들을 바이트로 변환하는 채널이다.

[source,java]
.ReadableHexChannel.java
----
public class ReadableHexChannel<T extends ReadableByteChannel>
        extends ReadableHexChannel<T> {

    // channel: 변환된 문자들을 읽을 채널
    // encoder: 문자를 숫자로 변활할 때 사용할 디코더
    public ReadableHexChannel(final T channel, final HexDecoder decoder) {
        super(channel);
        this.decoder = decoder;
    }

    protected HexDecoder decoder;
}
----

`read(ByteBuffer)` 메서드를 다음과 같이 재정의하였다.

[source,java]
.ReadableHexChannel.java#read(ByteBuffer)
----
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/ReadableHexChannel.java[lines=54..70]
----
<1> `src` 에 담을 수 있는 개수의 두 배만큼의 용량을 가지는 버퍼를 생성한다.
<2> `channel` 바이트를 읽고 홀수만큼 읽었으면 하나를 더 읽는다.
<3> `HexDecoder` 인터페이스의 `read(ByteBuffer,ByteBuffer)` 메서드를 이용해 디코드한다.

=== Exercises

. `HexEncoder.java` 에 배열을 이용하는 메서드를 구현하라.
+
[source,java]
.HexEncoder#encode(byte[],int,int,byte[],int)
----
// inarr 의 inoff 부터 inlen 만큼의 숫자를 인코딩하고 결과를 outarr 의 outoff 부터 기록한다.
default void encode(final byte[] inarr, final int inoff, final int inlen,
                    final byte[] outarr, final int outoff) {
    // @todo: implement
    // 인자들의 유효성을 검증하자.
    // outarr 의 outoff 부터 최소한 몇 개의 배열공간이 필요할까?
}
----
. `HexDcoder.java` 에 배열을 이용하는 메서드를 구현하라.
+
[source,java]
.HexDecoder#encode(byte[],int,int,byte[],int)
----
// inarr 의 inoff 부터 inlen 만큼의 문자를 디코딩하고 결과를 outarr 의 outoff 부터 기록한다.
default void decode(final byte[] inarr, final int inoff, final int inlen,
                    final byte[] outarr, final int outoff) {
    // @todo: implement
    // 인자들의 유효성을 검증하자.
    // inlen 이 홀수이면 유효한 값일까?
    // outarr 의 outoff 부터 최소한 몇 개의 배열공간이 필요할까?
}
----

=== hex-codec-lib
hex-codec-api 모듈에 정의되어 있는 두개의 인터페이스를 구현한 모듈이다.

==== HexEncoderImpl.java

`HexEncoder` 인터페이스를 구현한 클래스이다.

[source,java]
.HexEncoderImpl.java
----
public class HexEncoderImpl implements HexEncoder {
    // @todo: implement
}
----

`encodeOctet(int,ByteBuffer)` 메서드를 구현하기 전에 네 개의 비트로 이루어진 숫자(nibble)를 한 개의 hex 문자로 변환하는 메서드를 정의해 보자.
[source,java]
.HexEncoderImpl.java#encodeNibble(int)
----
include::../../../../hex-codec-lib/src/main/java/com/github/jinahya/verbose/hex/HexEncoderImpl.java[lines=20..36]
----

주어진 값이 `0` 부터 `9` 까지의 값이면 그값에 `48` 을 더해서 `'0'`(`48`)부터 `'9'`(`57`)까지의 값을 반환하고 `10` 부터 `15` 까지의 값이면 그 값에 `55` 를 더해서 `'A'`(`65`)부터 `'F'`(`70`)까지의 값을 반환한다.

[CAUTION]
====
`decoded` 의 값이 `0` 부터 `15` 까지의 값이라 가정한 코드이다. `encodedNibble(int)` 메서드가 `private` 메서드이고 `HexEncoderImpl` 클래스에서만 사용된다는 점을 감안하더라도 좋은 코드라 할 수 없다. 다음과 같이 수정하면 더 좋은 코드가 아닐까 한다.
[source,java]
----
        switch (decoded & 15) { // 하위 네 개의 비트만 사용한다.
            // ...
        }
----
====

이제 `encodeOctet(int, ByteBuffer)` 를 다음과 같이 구현할 수 있다.
[source,java]
.HexEncoderImpl.java#encodeOctet(int,ByteBuffer)
----
include::../../../../hex-codec-lib/src/main/java/com/github/jinahya/verbose/hex/HexEncoderImpl.java[lines=38..47]
----
<1> `decoded` 를 오른쪽으로 `4` 만큼 쉬프트한 후 `15` 와 AND 연산하여 상위 네 개의 비트가 표현하는 첫번째 nibble을 구한다.
<2> `decoded` 와 `15` 를 AND 연산하여 하위 네 개의 비트가 표현하는 두번째 nibble을 구한다.

[TIP]
====
만약 `encodeNibble(int)` 메서드가 주어진 값의 하위 네 개의 비트만 사용한다는 것이 보장된다면 다음과 같이 호출할 수도 있다.
[source,java]
----
encoded.put((byte) encodeNibble(decoded >> 4));
encoded.put((byte) encodeNibble(decoded));
----
====

==== HexDecoderImpl.java
`HexDecoder` 인터페이스를 구현한 클래스이다.
[source,java]
.HexDecoderImpl.java
----
public class HexDecoderImpl implements HexDecoder {
    // @todo: implement
}
----
`decodeOctet(int)` 메서드를 구현하기 전에 한 개의 hex 문자를 네 개의 비트로 이루어진 숫자(nibble)로 변환하는 메서드를 정의해 보자.
[source,java]
.HexDecoderImpl#decodeNibble(int)
----
include::../../../../hex-codec-lib/src/main/java/com/github/jinahya/verbose/hex/HexDecoderImpl.java[lines=20..43]
----
<1> 주어진 값이 `'0'`(`48`)부터 `'9'`(`57`)까지의 값이면 그 값에서 `48` 을 뺀 값을 반환한다.
<2> 대문자 `'A'`(`65`)부터 `'F'`(`70`) 까지의 값이면 그 값에서 `55` 를 뺀 값을 반환한다.
<3> 소문자 `'a'`(`97`) 부터 `'f'`(`102`) 까지의 값이라고 가정하고 그 값에서 `87` 를 뺀 값을 반환한다.

앞서 `HexEncoderImpl` 클래스는 무조건 대문자로 변환했지만 여기서는 소문자로 변환된 값들도 모두 처리한다.

[CAUTION]
====
역시나 가정해서 처리한 부분이 있다. 다음과 같이 모든 경우에 대해 확실한 코드를 사용하는 편이 더 훌륭한 코드가 아닐까 한다.
[source,java]
----
            case 'a': //  97, 0x61
            case 'b': //  98, 0x62
            case 'c': //  99, 0x63
            case 'd': // 100, 0x64
            case 'e': // 101, 0x65
            case 'f': // 102, 0x66
                return encoded - 87; // to 10 ~ 15
            default:
                throw new HexDecoderException( // <1>
                        "unknown hex value: " + encoded);
----
<1> `HexDecoderException` 는 가상의 클래스이다.
====

이제 `decodeOctet(ByteBuffer)` 를 다음과 같이 구현할 수 있다.

[source,java]
.HexdecoderImpl.java#decodeOctet(ByteBuffer)
----
include::../../../../hex-codec-lib/src/main/java/com/github/jinahya/verbose/hex/HexDecoderImpl.java[lines=45..53]
----
첫 번째 문자를 디코딩하고 윈쪽으로 `4` 만큼 옮긴 값에 두번째 문자를 디코딩한 값을 OR 연산하여 반환한다.

[TIP]
====
만약 `decodeNibble(int)` 메서드가 네 개의 비트로 이루어진 숫자를 반환한다는 것이 보장된다면 다음과 같이 구현할 수도 있다.
[source,java]
----
return decodeNibble(decoded.get()) << 4 | decodeNibble(decoded.get());
----
====

==== Unit Testing Strategy

`HexEncoderImpl` 클래스와 `HexDecoderImpl` 클래스가 올바르게 구현되었고 정상적으로 동작한다는 것을 어떻게 시험해야 할까? 단순히 시험에 사용할 데이터를 생성하고 `HexEncoderImpl` 객체를 이용해 인코드한 후 다시 `HexDecoderImpl` 객체로 디코드한 값을 비교하면 되지 않을까? 이 경우에 결과적으로 처음 입력한 데이터와 같은 결과를 얻었다 하더라도 두 클래스가 올바르게 작성되었다고 볼 수 없다. 두 클래스 모두 숫자 `15` 에 `'F'` 가 아닌 `'G'` 를 사용했더라도 시험을 통과하게 된다. 때문에 `HexEncoderImpl` 클래스와 `HexDecoderImpl` 클래스를 독립적으로 분리하여 각각의 기능을 비교해서 시험해 볼 수 있는 별도의 자료 혹은 라이브러리를 사용할 필요가 있다.

===== RFC 4648: The Base16, Base32, and Base64 Data Encodings
{rfc-4648}[RFC 4648] 의 http://tools.ietf.org/html/rfc4648#section-10[10. Test Vectors] 항목에 우리가 사용할 수 있는 테스트 벡터가 정의되어 있다. 아래와 같이 클래스를 하나를 만들고 테스트 벡터를 정의하였다.
[source,java]
.Rfc4648TestVectors.java#BASE16
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/Rfc4648TestVectors.java[lines=62..70]
----
`BASE16` 필드를 직접 노출하지 않고 다음과 같이 메서드를 하나 추가하여 데이터를 사용할 수 있게 했다.
[source,java]
.Rfc4648TestVectors.java#base16(BiConsumer)
----
    // 주어진 BiConsumer 의 accpet(String, String) 메서드에 BASE16 리스트의 값들을 전달한다.
    // 첫 번째 인자에는 BASE16 리스트의 짝수 번째 문자열을,
    // 두 번째 인자에는 BASE16 리스트의 홀수 번째 문자열을 제공한다.
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/Rfc4648TestVectors.java[lines=97..101]
----

===== Apache Commons Codec
{project-commons-codec}[Apache Commons Codec] 라이브러리의 {apidocs-commons-codec}/org/apache/commons/codec/binary/Hex.html[`Hex`] 클래스를 이용하여 인코딩/디코딩 결과를 교차 확인한다.

===== Guava: Google Core Libraries for Java
{project-guava}[Guava] 라이브러리에 포함된 {apidocs-guava}/com/google/common/io/BaseEncoding.html[`BaseEncoding`] 클래스를 이용하여 인코딩/디코딩 결과를 교차 확인한다.

==== HexEncoderImplTest.java

`HexEncoderImpl` 클래스의 기능을 확인하기 위한 시험클래스이다. 우선 아래와 같이 `Rfc4648TestVectors` 클래스를 이용하여 `HexEncoderImpl` 클래스의 기능을 시험한다.
[source,java]
.HexEncoderImplTest.java#encodeVerboseCompareRfc4648()
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexEncoderImplTest.java[lines=37..42]
----
<1> 테스트 벡터에 정의된 값(`d`, 인코드할 값)을 변환한 후 제시된 값(`e`, 인코드된 결과값)과 비교한다.

아래는 `Hex` 클래스를 이용하여 `HexEncoderImpl` 클래스의 기능을 확인하는 시험항목이다.

[ditaa]
....
              +------------+                 +-----+
  created --> |{io}        |                 |{io} |
              | HexEncoder | --> encoded --> | Hex |
     ^        |cBLU        |                 |cGRE | --> decoded
     |        +------------+                 +-----+
     |                                                      ^
     |                                                      |
     \----------------------- compare ----------------------/
....

[source,java]
.HexEncoderImplTest.java#encodeVerboseDecodeCommons()
----
    // create -> HexEncoderImpl -> Hex -> decoded
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexEncoderImplTest.java[lines=49..57]
----
<1> 인코드할 배열을 생성한다.
<2> 두배의 크기를 가지는 배열을 생성한 후 `encode(ByteBuffer,ByteBuffer)` 메서드를 이용하여 인코드한다.
<3> 인코드된 결과를 {apidocs-commons-codec}/org/apache/commons/codec/binary/Hex.html#decode(byte%5B%5D)[`Hex#decode(byte[\])`] 메서드를 이용하여 디코드한다.
<4> 처음 생성한 배열과 디코드한 결과를 비교한다.

아래는 `BaseEncoding` 클래스를 이용하여 `HexEncoderImpl` 클래스의 기능을 확인하는 시험항목이다.

[ditaa]
....
              +------------+                 +--------------+
  created --> |{io}        |                 |{io}          |
              | HexEncoder | --> encoded --> | BaseEncoding |
     ^        |cBLU        |                 |cGRE          | --> decoded
     |        +------------+                 +--------------+
     |                                                               ^
     |                                                               |
     \--------------------------- compare ---------------------------/
....

[source,java]
.HexEncoderImplTest.java#encodeVerboseDecodeGuava()
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexEncoderImplTest.java[lines=62..71]
----
<1> 인코드한 값을 {apidocs-guava}/com/google/common/io/BaseEncoding.html#decode(java.lang.CharSequence)[`BaseEncoding.decode(CharSequence)`] 메서드를 이용하여 디코드한다.

==== HexDecoderImplTest.java

`HexDecoderImpl` 클래스의 기능을 확인하기 위한 시험클래스이다. `HexEncderImplTest` 클래스와 마찬가지로 `Rfc4648TestVectors` 클래스를 이용하여 `HexDecoderImpl` 클래스의 기능을 시험한다.
[source,java]
.HexDecoderImplTest.java#decodeVerboseCompareRfc4648()
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexDecoderImplTest.java[lines=36..41]
----
<1> 테스트 벡터에 정의된 값(`e`, 인코드된 값)을 디코딩한 후 제시된 값(`d`, 디코딩된 값)과 비교한다.

다음 메서드는 `Hex` 클래스를 이용하여 `HexDecoderImpl` 클래스의 기능을 확인한다.

[ditaa]
....
              +-----+                 +------------+
  created --> |{io} |                 |{io}        |
              | Hex | --> encoded --> | HexDecoder |
     ^        |cBLU |                 |cGRE        | --> decoded
     |        +-----+                 +------------+
     |                                                      ^
     |                                                      |
     \----------------------- compare ----------------------/
....

[source,java]
.HexDecoderImplTest.java#encodeCommonsDecodeVerbose()
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexDecoderImplTest.java[lines=46..54]
----
<1> 입력 배열을 생성한다.
<2> 생성한 배열을 {apidocs-commons-codec}/org/apache/commons/codec/binary/Hex.html#encode(byte%5B%5D)[`Hex#encode(byte[\])`] 메서드를 이용해 인코드한다.
<3> 절반 크기의 출력 배열을 생성한 후 `decode(ByteBuffer,ByteBuffer)` 메서드를 이용해 디코드한다.
<4> 입력 배열과 출력 배열을 비교한다.

다음 메서드는 `BaseEncoding` 클래스를 이용하여 `HexDecoderImpl` 클래스의 기능을 확인한다.

[ditaa, "encodeGuavaDecodeVerbose"]
....
              +--------------+                 +------------+
  created --> |{io}          |                 |{io}        |
              | BaseEncoging | --> encoded --> | HexDecoder |
     ^        |cBLU          |                 |cGRE        | --> decoded
     |        +--------------+                 +------------+
     |                                                               ^
     |                                                               |
     \--------------------------- compare ---------------------------/
....

[source,java]
.HexDecoderImplTest.java#encodeGuavaDecodeVerbose()
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexDecoderImplTest.java[lines=59..68]
----
<1> 입력 배열을 {apidocs-guava}/com/google/common/io/BaseEncoding.html#decode(java.lang.CharSequence)[`BaseEncoding#decode(CharSequence)`] 메서드를 이용해 디코드한다.

==== Copying Streams, Channels, and Files
자바 API 를 이용하여 파일을 복사하는 방법은 꽤나 많은 방법들이 사용되고 있지만 그만큼 부정확한 코드를 생성할 요지도 많은 듯 하다. 우선 `InputStream` 객체에서 `OutputStream` 객체로 데이터를 복사하는 메서드를 정의해 보자.

[source,java]
.IoUtils.java#copy(InputStream,OutputStream)
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/IoUtils.java[lines=44..52]
----
<1> 버퍼를 하나 생성하고
<2> `input` 객체의 `read(byte[])` 메서드에 버퍼를 전달해서 `-1`(`end-of-stream`) 이 반환되기 전까지, 반복해서,
<3> `output` 에 `write(byte[], int, int)` 메서드를 이용해서 기록한다.

****
{apidocs-javase}/java/io/InputStream.html#read-byte:A-[`InputStream#read(byte[\])`] 메서드의 설명을 잘 읽어 본 후 아래 코드에 대해 생각해 보자.
[source,java]
----
        for (int read; (read = input.read(buffer)) > 0; count += read)
----
****

두 파일을 전달받아 복사하는 메서드를 다음과 같이 구현할 수 있다.

[source,java]
.IoUtils.java#copy(File,File)
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/IoUtils.java[lines=54..61]
----
<1> `flush()` 메서드를 명시적으로 호출하여 모든 데이터가 파일에 기록되는 것을 보장한다.

[TIP]
====
`OutputStream` 객체 혹은 `Writer` 객체에 값을 기록한 후 `close()` 메스드를 호출하기 전에 (혹은 필요한 때마다) `flush()` 메서드를 꼭 호출해서 쌓여(bufferd) 있는 데이터를 밀어내야 한다.
====

[CAUTION]
====
`close()` 메서드가 호출될 때 `flush()` 메서드가 자동으로 호출된다고 믿으면 안된다. 몇몇 `InputStream` 클래스와 `Writer` 클래스를 확장한 클래스들이 `close()` 메서드에서 `flush()` 메서드를 호출하도록 구현되고 (문서에) 기술되었을 뿐, `close()` 메서드를 정의한 {apidocs-javase}/java/lang/AutoCloseable.html[`AutoCloseable`] 인터페이스와 그 인터페이스를 확장한 {apidocs-javase}/java/io/Closeable.html[`Closeable`] 인터페이스 어디에도 `close()` 메서드가 `flush()` 메서드를 호출한다고 기술된 부분이 없다.
====

다음은 `ReadableByteChannel` 객체와 `WritableByteChannel` 객체를 전달 받아 데이터를 복사하는 메서드이다.
[source,java]
.IoUtils.java#copy1(ReadableByteBuffer, WritableByteBuffer)
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/IoUtils.java[lines=63..77]
----
<1> `ReadableByteChannel#read(ByteBuffer)` 메서드를 이용해 데이터를 버퍼에 채운다.
<2> 버퍼를 뒤집어 (버퍼에 읽혀진 데이터를) 기록할 수 있는 상태로 만든 후
<3> `WritableByteChannle#write(ByteBuffer)` 메서드에 버퍼를 전달하여 기록한다.
<4> 버퍼에 남아 있는 내용을 앞쪽으로 모은다.
<5> 버퍼에 남아 있는 내용을 모두 기록한다.

****
`copy1(ReadableByteChannel,WritableByteChannel)` 메서드는 `write(ByteBuffer)` 메서드를 한 번만 호출하는 대신 `compact()` 메서드를 사용해서 데이터를 계속 버퍼의 앞쪽으로 모으는 작업을 한다. [참조: http://shop.oreilly.com/product/9780596002886.do[Java NIO, O'Reilly Media]]
****

[source,java]
.IoUtils.java#copy2(ReadableByteBuffer,WritableByteBuffer)
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/IoUtils.java[lines=79..92]
----
<1> 버퍼에 읽혀진 모든 데이터를 기록한다.

****
`copy2(ReadableByteChannel,WritableByteChannel)` 메서드는 데이터를 앞쪽으로 모으는 작업을 하지 않는 대신 버퍼에 데이터가 남아 있을 동안 `write(ByteBuffer)` 메서드를 계속 호출한다. [참조: http://shop.oreilly.com/product/9780596002886.do[Java NIO, O'Reilly Media]]
****

아래는 `java.nio.file.Path` 형의 객체 두개를 전달받아 복사하는 메서드이다.

[source,java]
.IoUtils.java#copy1(Path,Path)
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/IoUtils.java[lines=105..114]
----
<1> 갱신된 내용이 저장소에 기록되는 것을 보장한다.

[NOTE]
====
{apidocs-javase}/java/nio/channels/FileChannel.html#force-boolean-[`FileChannel#force(boolean)`] 메서드에 `true` 값을 전달하여 데이터뿐만 아니라 변경된 https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html[메타정보]도 같이 저장되도록 할 수 있다.
====
[NOTE]
====
`FileChannel#force(boolean)` 메서드를 사용하는 대신 `FileChannel#open` 메서드에 {apidocs-javase}/java/nio/file/StandardOpenOption.html#DSYNC[`StandardOpenOption#DSYNC`] 혹을 {apidocs-javase}/java/nio/file/StandardOpenOption.html#DSYNC[`StandardOpenOption#SYNC`] 를 전달하여 자동으로 처리되게끔 할 수도 있다.
====

`FileChannel` 클래스의 {apidocs-javase}/java/nio/channels/FileChannel.html#transferTo-long-long-java.nio.channels.WritableByteChannel-[`transferTo`] 메서드와 {apidocs-javase}/java/nio/channels/FileChannel.html#transferFrom-java.nio.channels.ReadableByteChannel-long-long-[`transferFrom`] 메서드는 OS 수준의 기능을 사용함으로써 버퍼를 사용하여 읽기/쓰기를 반복하는 구문보다 효과적으로 작업을 수행한다.

다음은 `trasferTo` 메서드를 사용해서 파일을 복사하는 메서드이다.
[source,java]
.IoUtils.java#copy2(Path,Path);
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/IoUtils.java[lines=116..130]
----

다음은 `trasferFrom` 메서드를 사용해서 파일을 복사하는 메서드이다.
[source,java]
.IoUtils.java#copy2(Path,Path);
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/IoUtils.java[lines=132..146]
----

==== Using Message Digests

두 개의 파일이 주어졌을 때 두 파일의 내용이 같은지 어떻게 확인할 수 있을까? 두 파일을 처음부터 끝까지 바이트별로 비교하는 것도 가능한 방법중에 하나일 수 있다. 또 다른 방법은 {apidocs-javase}/java/security/MessageDigest.html[`java.security.MessageDigest`] 클래스를 이용하여 각 파일의 메시지 다이제스트 값을 구한 후 두 값을 비교하는 것이다.

다음은 `InputStream` 객체와 알코리즘 이름을 받아서 메시지 다이제스트 값을 구하는 메서드이다.

[source,java]
.MdUtils.java#digest1(InputStream,String)
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/MdUtils.java[lines=40..50]
----
<1> `algorithm` 값을 이용하여 `MessageDigest` 객체를 생성한다.
<2> `input` 에서 데이터를 읽은 후 `digest` 객체에 갱신한다.
<3> `digest` 에서 결과값을 구하여 반환한다.

아래 메서드는 {apidocs-javase}/java/security/DigestInputStream.html[`DigestInputStream`] 클래스를 사용한다.

[source,java]
.MdUtils.java#digest2(InputStream,String)
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/MdUtils.java[lines=52..58]
----
<1> `InputStream` 객체와 `MessageDigest` 객체를 이용하여 `DigestInputStream` 객체를 생성한다.
<2> `DigestInputStream` 의 데이터를 읽는다. (내부적으로 읽힌 데이터가 `digest` 에 갱신된다.)

아래는 파일을 전달 받아 그 파일의 메시지 다이제스트를 반환하는 메서드이다.

[source,java]
.MdUtils.java#digest(File,String)
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/MdUtils.java[lines=70..75]
----

다음은 `ReadableByteChannel` 객체에서 데이터를 읽어서 메시지 다이제스트를 계산하는 메서드이다.

[source,java]
.MdUtils.java#digest(ReadableByteChannel,String)
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/MdUtils.java[lines=77..87]
----
<1> `buffer` 에 채워진 데이터를 `digest` 에 갱신한다.

아래는 `Path` 객체를 전달 받아 메시지 다이제스트를 반환하는 메서드이다.

[source,java]
.MdUtils.java#digest(Path,String)
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/MdUtils.java[lines=89..94]
----

==== HexStreamTest.java

`HexIputStream` 클래스와 `HexOutputStream` 클래스를 시험하기 위한 클래스이다.

[ditaa, "encodeDecodeFile"]
....
                +----------------------------------+
  created ----> |{io}                              |
                |FileInputStream -> HexOutputStream|
     ^          |cBLU                              | -----\
     |          +----------------------------------+      |

 (compare)                                             encoded

     |          +----------------------------------+      |
     v          |{io}                              | <----/
                |FileOutputStream <- HexInputStream|
  decoded <---- |cGRE                              |
                +----------------------------------+
....

[source,java]
.HexStreamTest.java#encodeDecodeFile()
----
public class HexStreamTest {

    @Test
    public void encodeDecodeFile()
            throws IOException, NoSuchAlgorithmException {
        // @todo: implement
    }
}
----

파일(`created`)을 하나 생성하고 무작위로 내용을 채운다.

[source,java]
.HexStreamTest.java#encodeDecodeFile()
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexStreamTest.java[lines=28..34]
----
<1> VM 이 종료될 때 파일을 삭제한다.

파일(`encoded`)을 하나 더 만들고 `HexOutputStream` 클래스를 이용하여 복사한다. (인코드한다.)

[source,java]
.HexStreamTest.java#encodeDecodeFile()
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexStreamTest.java[lines=35..44]
----

또 다른 파일(`decoded`)에 `HexInputStream` 클래스를 이용하여 복사한다. (디코드한다.)

[source,java]
.HexStreamTest.java#encodeDecodeFile()
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexStreamTest.java[lines=45..54]
----

세 개의 파일들은 각각의 크기가 다음의 조건을 만족한다.

[source,java]
.HexStreamTest.java#encodeDecodeFile()
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexStreamTest.java[lines=55..56]
----

처음 생성한 파일(`created`)과 마지막의 디코드된 파일(`decoded`)의 내용을 비교한다.

[source,java]
.HexStreamTest.java#encodeDecodeFile()
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexStreamTest.java[lines=57..61]
----

==== HexChannelTest.java

[source,java]
.HexChannelTest.java
----
public class HexChannelTest {

    @DataProvider
    private Object[][] algorithms() {
        return new Object[][]{{"MD5"}, {"SHA-1"}, {"SHA-256"}};
    }

    @Test(dataProvider = "algorithms")
    public void encodeDecodePath(final String algorithm)
            throws IOException, NoSuchAlgorithmException {
        // @implement
    }
}
----

파일을 하나(`created`) 생성하고 무작위로 내용을 채운 다음 메시지 다이제스트 값을 미리 계산해 놓는다.

[source,java]
.HexChannelTest.java#encodeDecodePath()
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexChannelTest.java[lines=42..48]
----
<1> {apidocs-javase}/java/nio/file/StandardOpenOption.html#DSYNC[`StandardOpenOption#DSYNC`] 옵션을 명시해서 갱신되는 내용이 저장소에 동시에(synchronously) 기록되도록 한다.

파일을 하나 더(`encoded`) 생성하고 `WritableHexChannel` 클래스를 이용해서 복사한다. (인코드한다.)

[source,java]
.HexChannelTest.java#encodeDecodePath()
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexChannelTest.java[lines=49..58]
----
<1> {apidocs-javase}/java/nio/file/StandardOpenOption.html#DELETE_ON_CLOSE[`StandardOpenOption#DELETE_ON_CLOSE`] 옵션을 명시해서 `close()` 될 때 파일이 삭제도록 한다.

또 다른 파일(`decoded`)에 `ReadableHexChannel` 클래스를 이용해서 복사한 후 (디코드한 후) 메시지 다이제스트 값을 구한다.

[source,java]
.HexChannelTest.java#encodeDecodePath()
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexChannelTest.java[lines=59..69]
----

두 메시지 다이제스트 값을 비교한다.

[source,java]
.HexChannelTest.java#encodeDecodePath()
----
include::../../../../hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexChannelTest.java[lines=70..70]
----

=== Exercises
. `HexEncoderImpl#encodeNible(int)` 과 `HexDecoderImpl#decodeNibble(int)` 의 `switch` 구문을 `if/else` 구문으로 바꿔보자.
+
. 시험 클래스를 하나 추가하고 클래스 파일의 처음 4 개의 바트드들을 `base16` 으로 출력해 보자.
+
[source,java]
.ClassFileTest.java#cafebabe()
----
include::../../../../verbose-java-book/src/test/java/com/github/jinahya/verbose/hex/ClassFileTest.java[lines=29..44]
----
+
[NOTE]
====
`class` 파일의 첫 네 바이트는 클래스 파일임을 식별할 수 있는 고정 값이다.

https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1[Chapter 4. The `class` File Format (The Java(R) Virtual Machine Specification)]
====
. 테스트 클래스를 하나 추가하고 자신의 이름을 `base16` 으로 출력해보자.
+
[source,java]
.CharsetTest.java#name()
----
include::../../../../verbose-java-book/src/test/java/com/github/jinahya/verbose/hex/CharsetTest.java[lines=32..65]
----
. 다음 조건을 만족하는 메서드를 구현해 보자.
+
[source, java]
----
// input 에서 output 으로 데이터를 복사한다.
// 최대 count 만큼만 복사한다. (count 가 -1L 이면 스트림(input)의 끝까지 복사한다.)
// length 만큼의 길이를 가지는 버퍼를 사용한다.
// 실제로 복사된 바이트 개수를 반환한다.
// (count 가 -1L 이 아닐 경우 count 보다 같거나 작아야 한다.)
long copy(InputStream input, OutputStream output, long count, int length)
    throws IOException {
    // @todo: implement
    // 인자들의 유효성을 확인하자.
    return 0L;
}
----
. 다음 조건을 만족하는 메서드를 구현해 보자.
+
[source,java]
----
// readable 에서 writable 로 데이터를 복사한다.
// 최대 count 만큼만 복사한다. (count 가 -1L 이면 채널(readable)의 끝까지 복사한다.)
// capacity 만큼의 용량을 가지는 버퍼를 사용한다.
// direct 가 true 이면 버퍼를 생성할 때 다이렉트 버퍼를 생성한다.
// 실제로 복사된 바이트 개수를 반환한다.
// (count 가 -1L 이 아닐 경우 count 보다 같거나 작아야 한다.)
long copy(ReadableByteChannel readable, WritableByteChannel writable,
          long count, int capacity, boolean direct)
    throws IOException {
    // @todo: implement
    // 인자들의 유효성을 확인하자.
    return 0L;
}
----

=== percent-codec-api

다음과 같이 정의된 URL이 있다고 가정하자.

----
http://.../files/{file}?descriptor={descriptor}
----

`{file}` 부분과 `{descriptor}` 부분에 `a/b?c` 와 `e&f=g/h` 을 각각 대입하면 유효하지 않거나 의도하지 않은 값이 나온다.

----
http://.../files/a/b?c?descriptor=e&f=g/h
----

때문에 각 부분별로 허용되지 않는 문자들을 다음과 같이 적절하게 인코딩한 후 사용해야 한다.

----
http://.../files/a%2Fb%3Fc?descriptor=e%26f%3Dg%2Fh
----

https://tools.ietf.org/html/rfc3986[RFC 3986]의 https://tools.ietf.org/html/rfc3986#section-2.1https://tools.ietf.org/html/rfc3986#section-2.1[Percent-Encoding] 항목에 위 예시에서 사용된 방법이 정의되어 있다. 주어진 문자가 https://tools.ietf.org/html/rfc3986#section-2.3[Unreserved Characters] 항목에 정의된 범위(`알파벳`, `숫자`, `'-'`, `'.'`, `'_'`, `'~'`) 밖이면 `'%'` 하나와 두개의 `hex` 문자로 표현한다.

[NOTE]
====
http://docs.oracle.com/javase/8/docs/api/java/net/URLEncoder.html[`java.net.URLEncoder`] 와 http://docs.oracle.com/javase/8/docs/api/java/net/URLDecoder.html[`java.net.URLDecoder`] 는 해당 문서에 기술되어 있듯이 http://www.w3.org/TR/html5/forms.html#url-encoded-form-data[HTML]에 정의된 `application/x-www-form-urlencoded` 형식을 위한 코덱이다. `'~'` 대신 `'*'` 를 그대로 표기하며 공백 문자(`'{nbsp}'`)를 `"%20"` 이 아닌 `'+'` 로 인코딩한다. 아래 코드는 `"value"` 라는 필드 이름과 `"홍 길동"` 이라는 필드 값을 서버에 전달하는 예시 문서이다. (공백 문자(`'{nbsp}'`)가 `'+'` 로 인코딩되어 있다.)
----
POST /names HTTP/1.1
Host: www.example.com:80
Content-Type: application/x-www-form-urlencoded
Content-Length: 34

value=%ED%99%8D+%EA%B8%B8%EB%8F%99
----
====

==== PercentEncoder.java

Percent Encoding을 위한 인터페이스이다.

[source,java]
.PercentEncoder.java
----
@FunctionalInterface
public interface PercentEncoder {

    // 바이트(decoded)를 인코딩 한 후 결과(한 개 혹은 세 개의 문자)를 버퍼(encoded)에 담는다.
    // 버퍼(encoded)에 공간이 충분치 않으면 BufferOverflowException 을 던진다.
    void encodeOctet(final int decoded, final ByteBuffer encoded);
}
----

==== PercentDecoder.java

Percent Decoding을 위한 인터페이스이다.

[source,java]
.PercentDecoder.java
----
@FunctionalInterface
public interface PercentDecoder {

    // 버퍼(encoded)에서 필요한 만큼(1개 혹은 3개)의 문자를 디코딩하고 그 결과를 반환한다.
    // 버퍼(encoded)에 필요한 만큼의 문자가 없으면 BufferUnderflowException 을 던진다.
    int decodeOctet(final ByteBuffer encoded);
}
----

=== percent-codec-lib

pecent-codec-api 에 정의된 인터페이스들을 구현한 모듈이다. hex-codec-api 와 hex-codec-lib 을 통해 octet을 두개의 hex 문자로 변환하는 방법을 이미 구현했으므로 그 모듈들을 사용한다. 다음과 같이 의존성을 확인해 보자.

[source,text]
.percent-codec-lib/dependency:tree
----
$ pwd
/.../path/to/.../verbose-java/percent-codec-lib
$ mvn dependency:tree -Dscope=runtime
...
[INFO] --- maven-dependency-plugin:x.y.z:tree (default-cli) @ percent-codec-lib ---
[INFO] com.github.jinahya:percent-codec-lib:jar:<version>
[INFO] +- com.github.jinahya:hex-codec-api:jar:<version>:compile
[INFO] +- com.github.jinahya:hex-codec-lib:jar:<version>:runtime
[INFO] \- com.github.jinahya:percent-codec-api:jar:<version>:compile
...
$
----
hex-codec-api 를 compile scope 로 정의하여 구현작업에 사용되었고 hex-codec-lib 을 runtime scope 로 정의하여 실제로 동작할 때만 사용되도록 설정하였다.

==== PercentEncoderImpl.java

[source,java]
public class PercentEncoderImpl implements PercentEncoder {
    // @todo: implement
}

우선 다음과 같이 `HexEncoder` 개체를 적재하는 코드를 작성하자.
[source,java]
.PercentEncoderImpl.java#hexEncoder()
----
    protected HexEncoder hexEncoder() {
        if (hexEncoder == null) {
            try {
                hexEncoder = load(HexEncoder.class).iterator().next();
            } catch (final NoSuchElementException nsee) {
                throw new RuntimeException("no hex encoder loaded", nsee);
            }
        }
        return hexEncoder;
    }

    private HexEncoder hexEncoder;
----
그리고 다음과 같이 `encodeOctet(int, ByteBuffer)` 를 구현한다.
[source,java]
.PercentEncoderImpl.java#encodeOctet(int, ByteBuffer)
----
include::../../../../percent-codec-lib/src/main/java/com/github/jinahya/verbose/percent/PercentEncoderImpl.java[lines=34..48]
----
<1> 인코딩할 필요가 없는 octet 이면 그대로 버퍼에 담는다.
<2> 인코딩이 필요한 문자는 한 개의 `"%"` 를 버퍼에 담고
<3> `HexEncoder` 에 정의된 `encodeOctet(int, ByteBuffer)` 를 이용해 두개의 hex 문자를 버퍼이 담는다.

==== PercentDecoderImpl.java

[source,java]
.PercentcoderImpl.java
----
public class PercentDecoderImpl implements PercentDecoder {
    // @todo: implement
}
----

`PercentEncoderImpl` 과 마찬가지로 `HexDecoder` 개체를 적재하는 코드를 작성하자.
[source,java]
.PercentDecoderImpl.java#hexDecoder()
----
    protected HexDecoder hexDecoder() {
        if (hexDecoder == null) {
            try {
                hexDecoder = load(HexDecoder.class).iterator().next();
            } catch (final NoSuchElementException nsee) {
                throw new RuntimeException("no hex decoder loaded", nsee);
            }
        }
        return hexDecoder;
    }

    private HexDecoder hexDecoder;
----
그리고 다음과 같이 `decodeOctet(int, ByteBuffer)` 를 구현한다.
[source,java]
.PercentDecoderImpl.java#decodeOctet(ByteBuffer)
----
include::../../../../percent-codec-lib/src/main/java/com/github/jinahya/verbose/percent/PercentDecoderImpl.java[lines=34..41]
----
<1> 첫 문자를 읽고 `"%"` 이면
<2> `HexDecoder` 에 정의된 `decodeOctet(ByteBuffer)` 를 이용해 두개의 hex 문자로부터 한 개의 octet 을 생성하고 반환한다.
<3> 인코딩이 필요치 않은 문자는 그대로 반환한다.
